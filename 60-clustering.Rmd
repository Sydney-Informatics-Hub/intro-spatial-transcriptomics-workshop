# Clustering{#clustering}



## Generate Clusters

To generate clusters, we first build a 'neighbourhood' graph. This is a network graph, that links up cells on the basis of their transcriptional similarity ('neighbours'). Its not something for looking at directly, its simply stored inside the object, but its an important input for downstream steps like clustering. 

Forget to run it and you'll generate an error.

Note that we need to specify the 'harmony' reduction, else it would default to 'pca'. Just like the UMAP, we want our clusters to represent different cell types or states, not the differences between individuals. 

```{r message=FALSE}
so <- FindNeighbors(so, reduction = "harmony", dims = 1:15)
```


Now clustering can be as simple as running 'FindClusters'. 
```{r message=FALSE}
so <- FindClusters(so)  
```

```{r message=FALSE}
DimPlot(so, group.by='seurat_clusters')
```


For the rest of the workshop, we'll use stick with that resolution of 0.8 - which was actually the default.


In real life, choosing a clustering resolution can be a cyclic process with cell type labelling. The 'correct' level of clustering is one that lets you answer the biological questions you are interested in. To broad and you'll have heterogeneity in your clusters, or too specific and and you'll have somewhat arbitrary clusters with too few cells to test anything. You may need to use different levels of clustering for different analyses, or choose to make sub-clusters in one particular celltype of interest.

The [clustree](https://doi.org/10.1093/gigascience/giy083) package can be a useful tool to evaluate different levels of clustering. There is an example of its use [here]( https://swbioinf.github.io/scRNAseqInR_Doco/clustering.html) in the context of single cell transcriptomics.


```{r message=FALSE, warning=FALSE}
so <- FindClusters(so, resolution = 0.8)  
```

```{r}
DimPlot(so, group.by='seurat_clusters')
```



