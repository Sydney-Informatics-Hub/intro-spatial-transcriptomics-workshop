# Clustering Labeling{#ClusterLabelling}

Classifying cells into meaningful celltypes (or cell states) is a time consuming, but extremely important, part of a spatial analysis.

It may involve pulling together multiple lines of evidence to assign celltype labels to cluster labels. Some approaches outlined below:



## Cluster Markers


```{r message=FALSE}
DimPlot(so, group.by='seurat_clusters')
```



```{r message=FALSE, warnings=FALSE}
so <- JoinLayers(so)
marker_table <- FindAllMarkers(so, group.by='seurat_clusters', only.pos=TRUE)
```


```{r}
marker_table_top <- marker_table %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1, p_val_adj < 0.01) %>%
    slice_head(n = 3)
```


```{r message=FALSE, warnings=FALSE}    
DotPlot(so, features = unique(marker_table_top$gene)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```


<!-- Plot cluster specific genes on a heatmap on a subset of 5000 cells. -->
<!-- ```{r message=FALSE, warnings=FALSE}     -->
<!-- #DefaultLayer(so[['RNA']]) <- 'data' -->
<!-- so.mini <- so[, sample(colnames(so), size =5000, replace=F)] -->
<!-- DoHeatmap(so.mini, assay='RNA', features = marker_table_top$gene)  -->

<!-- ``` -->


## Cell typing by reference

There are a number of tools that classify cells into types on the basis of similarity with a reference dataset. SingleR is one such tool.

```{r message=FALSE, warnings=FALSE}
library(SingleR)
```


But first we need to acquire a reference dataset. 

A typical reference would be from a public single cell datasets from a matched celltype with a trusted annotation. Look for a relevant paper which has provided their GEO accession number or similar. Note that not every study remembers to publish their annotations alongside their raw data, but the authors might be willing to supply you with a processed dataset if you ask.

Alternatively, there are some databases of single cell datasets - see [Human Cell Atlas](https://data.humancellatlas.org/) or [CELLxGENE datasets](https://cellxgene.cziscience.com/datasets). These databases also let you browse the data online - which is an excellent resource for the design or cell annotation stages; you can look up gene expression in a particular celltype to see if it matches what you are seeing.



The tabula sapiens project ([paper](https://www.science.org/doi/10.1126/science.abl4896)) as built a single cell atlas from a good number of human tissues. Its data is browse-able and hosted in the [cellXgene tabular sapiens collection](https://cellxgene.cziscience.com/collections/e5f58829-1a66-40b5-a624-9046778e74f5)


These are colon tissue samples, and there is a large intestine set listed (which includes colon samples). Conveniently, we can browse the data online to check if it will be suitable: via a [cellXgene interface](https://cellxgene.cziscience.com/e/7357cee7-9f7f-4ab0-8cec-90de8f047e38.cxg/)

Broad cell class looks pretty good. There's colon included. Some individual level effect in the UMAP (stem cells limited to 1-2 samples). It'll work, and there's an easy link to download the data.


The reference dataset has been pre-downloaded onto the VMs
```{sh eval=FALSE}
# Do not run, but these were the linux shell commands to get and rename the data
wget https://datasets.cellxgene.cziscience.com/82e3b450-6704-43de-8036-af1838daa7df.h5ad
mv 82e3b450-6704-43de-8036-af1838daa7df.h5ad tabula_sapiens_large_intestine_82e3b450-6704-43de-8036-af1838daa7df.h5ad
```


Its a .h5ad file, common from pythonic analyses. Luckily we can use the schard package to read it into R directly. But not to a seurat object. 

```{r eval=FALSE}
library(schard)
sce.ts_intestine = schard::h5ad2sce(ts_largeintestine_h5ad)
```

Instead it builds a SingleCellExperiment object - a data format central to bioconductor packages (this is fine, SingleR is from bioconductor too!). SCE objects work quite similarly to seurat objects, but have different notation - e.g. _colData_ and _rowData_ access the cell and gene information respectively.
```{r eval=FALSE}
DT::data.table(head(colData(sce.ts_intestine)))
DT::data.table(head(rowData(sce.ts_intestine)))
```


TODO: SHOW CODE FOR calling
TODO: LOAD PRECALLED from cell_typing.R


```{r eval=FALSE}
predictions_broad <- SingleR::SingleR(test = norm_matrix,
                                ref   = ref_norm_matrix,
                                labels = sce.ts_intestine.genename$broad_cell_class,
                                aggr.ref = TRUE, # builds a pseudobulk reference , speedier processing
                                BPPARAM = MulticoreParam(workers=8)
                                )

predictions_detailed <- SingleR::SingleR(test = norm_matrix,
                                ref   = ref_norm_matrix,
                                labels = sce.ts_intestine.genename$cell_type,
                                aggr.ref = TRUE, # builds a pseudobulk reference , speedier processing
                                BPPARAM = MulticoreParam(workers=8)
)
```




```{r}
predictions_broad_file    <- file.path("data","predictions_with_ts_intestine_broad_cell_class.RDS")
predictions_detailed_file <- file.path("data","predictions_with_ts_intestine_detailed_celltype.RDS")
predictions_broad    <- readRDS(predictions_broad_file)
predictions_detailed <- readRDS(predictions_detailed_file)
```

The predictions look like this
```{r}
predictions_broad
```



Pull them both into the annotation
```{r}
# We can do this because the order of cell is the same
stopifnot(all(rownames(predictions_broad) == colnames(so)))
so$singleR_pred_broad    <- predictions_broad$pruned.labels
so$singleR_pred_detailed <- predictions_detailed$pruned.labels
```


And plot on the UMAP

The clusters:
```{r}
DimPlot(so)
```

The broad predictions
```{r}
DimPlot(so, group.by = 'singleR_pred_broad', label = TRUE)
```

And the detailed predictions.  The detailed celltypes are more difficult to see - but some have clearly labelled.
```{r}
DimPlot(so, group.by = 'singleR_pred_detailed', label = TRUE) + NoLegend()
```



The delta next score gives you the distance between the called celltype, and the next most likely. A small difference could indicate uncertainty - from a difficult to classify cell, stray counts from a neighbouring cell , 
```{r}
so$singleR_delta.next_broad    <- predictions_broad$delta.next
so$singleR_delta.next_detailed <- predictions_detailed$delta.next

FeaturePlot(so, c('singleR_delta.next_broad','singleR_delta.next_detailed'))

VlnPlot(so, features='singleR_delta.next_broad', group.by='singleR_pred_broad', pt.size = 0) + NoLegend()
VlnPlot(so, features='singleR_delta.next_detailed', group.by='singleR_pred_detailed', pt.size = 0) + NoLegend()
```






Its nice to line those classifications up with clusters.

```{r}
## Celltype proportions
celltype_summary_table<- so@meta.data %>% as_tibble() %>%
  group_by(seurat_clusters, singleR_pred_broad ) %>%
  summarise(n_cells = n())


ggplot(celltype_summary_table, aes(x=seurat_clusters, y=n_cells, fill=singleR_pred_broad)) +
  geom_bar(position="fill", stat="identity") +
  theme_bw() +
  coord_flip() +
  theme(legend.position = "bottom") +
  scale_y_continuous(expand = c(0,0)) +
  ggtitle( "Celltyping vs clustering") 
  

```

## Spatial examination of plots

The clusters were defined purely on transcriptional similarity, but when plotted on tissue, their location pattern emerges.
Here we can see that cluster 1 is epithelial cells. 

Plotting both whole sample, and a zoomed in region of just one of the FOVs (in the cosmx definition) within it.

```{r  message=FALSE, warnings=FALSE}
so_sample <- so[, so$tissue_sample=="HC_a"]
ImageDimPlot(so_sample,
             fov          = "GSM7473682.HC.a",
             axes = TRUE,
             border.color = NA, border.size = 0.1,
             cols = 'polychrome', #See DiscretePalette()
             group.by = "seurat_clusters",
             boundaries   = "segmentation",
             crop=TRUE,
             nmols = 10000)

```

```{r message=FALSE, warnings=FALSE}
so_fov    <- so_sample[, so_sample$fov==1]
ImageDimPlot(so_fov,
             fov          = "GSM7473682.HC.a",
             axes = TRUE,
             border.color = NA, border.size = 0.1,
             cols = 'polychrome', #See DiscretePalette()
             group.by = "seurat_clusters",
             boundaries   = "segmentation",
             crop=TRUE,
             nmols = 10000)

```



What about the two sets of predictions?
```{r message=FALSE, warnings=FALSE}
ImageDimPlot(so_fov,
             fov          = "GSM7473682.HC.a",
             axes = TRUE,
             border.color = NA, border.size = 0.1,
             group.by =  'singleR_pred_broad',
             boundaries   = "segmentation",
             cols = 'polychrome', #See DiscretePalette()
             crop=TRUE)

```


## Recording celltype annotations.



```{r}
## Apply some cluster names
so$cluster_code <- factor( paste0("c", so$seurat_clusters),   levels=paste0('c', levels(so$seurat_clusters)))
Idents(so) <- so$cluster_code

cluster_content <- list(
  c0 = "B lymphocyte lineage", # JCHAIN/ MZB1 / DERL3 
  c1 = "Stem cell", 
  c2 = "Mixed",         
  c3 = "Fibroblast",              
  c4 = "Macrophage and Dendritic cell",  # See detailed predictions, and macrophages are important in this study.  
  c5 = "Intestinal epithelial cell",
  c6 = "Contractile cell",
  c7 = "B lymphocyte lineage",  # CD37 / CIITA / IGHM 
  c8 = "Endothelia",
  c9 = "granulocyte",
  c10 = "Mixed"
)

# c1 => c1: Stem cell
so$cluster_labels <- factor (
  paste0(names(cluster_content[as.character(so$cluster_code)]), ": ", cluster_content[as.character(so$cluster_code)]) ,
  levels = paste0( names(cluster_content), ": ", cluster_content)
)
```

```{r message=FALSE}
DimPlot(so, group.by='cluster_labels', label = TRUE) + NoLegend()
```


## Other methods


TODO: Discuss other approaches.

E.g. one of:
cell type based domain ID with hoodscanR,
expression-based domain ID,
looking at DEGs with enrichR 







## Pull in real annotation

The authors of this study have shared their actual celltypes. So in lieu of trying to figure this out - directly import their annotation

The 'singleR2' set is very detailed!

```{r}
annotation_file <- 'data/GSE234713_CosMx_annotation.csv.gz'
anno_table <- read_csv(annotation_file, show_col_types = F)
anno_table <- as.data.frame(anno_table)
rownames(anno_table) <- anno_table$id

so$paper_celltype <- factor(anno_table[colnames(so),]$subset)
so$paper_singleR2 <- factor(anno_table[colnames(so),]$SingleR2)
```

From there can use celltype labels on visualisation:

```{r message=FALSE, warnings=FALSE}
so_fov    <- so[, so$tissue_sample=="HC_a" & so_sample$fov==1]
ImageDimPlot(so_fov,
             fov          = "GSM7473682.HC.a",
             axes = TRUE,
             border.color = NA, border.size = 0.1,
             group.by = "paper_celltype",
             boundaries   = "segmentation",
             crop=TRUE)


ImageDimPlot(so_fov,
             fov          = "GSM7473682.HC.a",
             axes = TRUE,
             border.color = NA, border.size = 0.1,
             group.by = "paper_singleR2",
             boundaries   = "segmentation",
             crop=TRUE)
```



## Fun with annotations


Now we can do some fun plots with our cell types - for instance to see if there's change in proportions between samples. You could test this formally with [propellar](https://github.com/phipsonlab/speckle)


```{r}

## Celltype proportions
celltype_summary_table<- so@meta.data %>% as_tibble() %>%
  group_by(condition, tissue_sample, cluster_labels ) %>%
  summarise(n_cells = n())



ggplot(celltype_summary_table, aes(x=tissue_sample, y=n_cells, fill=cluster_labels)) +
  geom_bar(position="fill", stat="identity") +
  theme_bw() +
  coord_flip() +
  theme(legend.position = "bottom") +
  scale_y_continuous(expand = c(0,0)) +
  ggtitle( "Celltype composition") +
  facet_wrap(~condition, ncol = 1, scales = 'free_y')


```




